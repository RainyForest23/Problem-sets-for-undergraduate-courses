요청하신 연습문제 38문항에 대한 상세한 해설을 제시된 강의자료와 연습문제 내용을 바탕으로 작성했습니다. 각 답변 뒤에는 해당 내용을 지지하는 출처 번호가 표시되어 있습니다.

---

## 컴퓨터 네트워크 Midterm Exam 대비 연습문제 해설

### I. 용어 및 기본 개념 해설

1.  **Transport Layer의 주요 목표 5가지:**
    *   **Multiplexing** (다중화) 및 **Demultiplexing** (역다중화).
    *   **Reliable Data Transfer (rdt)** (신뢰할 수 있는 데이터 전송).
    *   **Flow Control** (흐름 제어).
    *   **Congestion Control** (혼잡 제어).
    *   **End-to-end (e2e) error detection** (종단 간 오류 감지).

2.  **Transport Layer와 Network Layer의 주요 기능 차이점:**
    *   **Transport Layer**는 **프로세스** 간의 논리적 통신 (logical communication between processes)을 제공합니다.
    *   **Network Layer (IP)**는 **호스트** (Host, 즉 종단 시스템) 간의 논리적 통신을 제공합니다.

3.  **TCP와 UDP의 비교:**
    *   **TCP (Transmission Control Protocol):** **연결 지향(Connection-oriented)** 프로토콜이며, **신뢰성(Reliable)** 있고, 순서대로(in-order) 데이터를 전달하며, 혼잡 제어(congestion control)와 흐름 제어(flow control) 기능을 제공합니다.
    *   **UDP (User Datagram Protocol):** **비연결(Connectionless)** 프로토콜이며, **비신뢰성(Unreliable)** 있고, 순서에 상관없이(unordered) 데이터를 전달합니다. "최선형(best-effort)" IP의 확장이며, 흐름 제어나 혼잡 제어를 제공하지 않습니다.

4.  **TCP 송수신 과정:**
    *   **송신자(Sender):** 애플리케이션 계층 메시지를 여러 개의 **세그먼트(segments)**로 나누어 Transport Header를 추가한 후 IP 계층(Network Layer)으로 전달합니다.
    *   **수신자(Receiver):** IP 계층으로부터 세그먼트를 수신하고, 헤더 값을 확인하여 세그먼트들을 **재조립(reassembles)**하여 메시지를 애플리케이션 계층으로 전달합니다.

5.  **참(True) / 거짓(False) 판단 (ACK piggyback):**
    *   **거짓 (False)**. Host B가 보낼 데이터가 없더라도, Host A가 보낸 데이터의 수신 확인(ACK)을 독립적인 세그먼트로 Host A에게 보내야 합니다. TCP는 신뢰적인 전송(reliable delivery)을 위해 ACKs에 의존하며, Host B는 ACK를 피기백(piggyback)할 수 없더라도 ACK를 보내야 합니다.

6.  **참(True) / 거짓(False) 판단 (unacknowledged bytes):**
    *   **참 (True)** [80c]. Host A가 아직 ACK를 받지 못한 채 보낼 수 있는 바이트의 수(in-flight data)는 수신자가 광고하는 수신 윈도우 크기($rwnd$)에 의해 제한됩니다. $rwnd$는 수신 버퍼($RcvBuffer$)의 여유 공간을 나타내므로, $rwnd$를 따르는 한 송신자가 보낸 데이터는 $RcvBuffer$ 크기를 초과하여 버퍼 오버플로우를 일으키지 않습니다 [48, 49, 80c].

7.  **QUIC (Quick UDP Internet Connections):**
    *   QUIC은 **UDP** 위에 구현된 **애플리케이션 계층 프로토콜**입니다.
    *   **주요 이점:** TCP는 연결 설정(TCP 3-way handshake)과 보안 설정(TLS handshake)을 순차적으로 수행하는 **두 번의 직렬 핸드셰이크**를 필요로 하는 반면, QUIC은 이 모든 기능(신뢰성, 혼잡 제어, 인증, 암호화, 상태 설정)을 **하나의 핸드셰이크(1 RTT)**로 완료하여 지연 시간을 줄입니다.

8.  **QUIC의 신뢰성/혼잡 제어 구현 위치:**
    *   QUIC은 UDP 상에서 동작하지만, 신뢰할 수 있는 데이터 전송, 혼잡 제어, 보안 등의 기능을 **애플리케이션 계층**에서 직접 구현합니다.

### II. Mux/Demux 및 Socket 해설

9.  **Multiplexing 시 정보:**
    *   송신자는 Transport Header에 **Source Port Number (출발지 포트 번호)**와 **Destination Port Number (목적지 포트 번호)**를 추가합니다.
    *   이 정보는 수신자 측에서 수신된 세그먼트를 올바른 프로세스/소켓으로 전달하는 **Demultiplexing (역다중화)**에 사용됩니다.

10. **세그먼트 전달에 활용되는 정보:**
    *   호스트는 IP 데이터그램의 **Source IP Address (출발지 IP 주소)** 및 **Destination IP Address (목적지 IP 주소)**와 세그먼트 헤더의 **Source Port Number** 및 **Destination Port Number**를 사용하여 올바른 소켓으로 세그먼트를 전달합니다.

11. **Connectionless (UDP) Demultiplexing:**
    *   수신 호스트는 주로 **Destination Port Number (목적지 포트 번호)**를 확인하여 올바른 소켓으로 UDP 데이터그램을 전달합니다.
    *   동일한 목적지 포트 번호를 가지는 UDP 데이터그램은 출발지 IP 주소나 출발지 포트 번호가 다르더라도 목적지 호스트의 동일한 소켓으로 전달됩니다.

12. **Connection-oriented (TCP) Demultiplexing:**
    *   수신 호스트는 수신된 TCP 세그먼트를 올바른 소켓으로 전달하기 위해 다음 4가지 정보(4-tuple)를 모두 사용합니다:
        1.  Source IP Address (출발지 IP 주소)
        2.  Source Port Number (출발지 포트 번호)
        3.  Destination IP Address (목적지 IP 주소)
        4.  Destination Port Number (목적지 포트 번호)

13. **웹 서버의 소켓 식별:**
    *   웹 서버가 다수의 클라이언트와 동시에 통신할 때, 각 연결은 고유한 **4-tuple**로 식별됩니다.
    *   서버의 IP 주소와 목적지 포트 번호는 같더라도, 클라이언트마다 **출발지 IP 주소**와 **출발지 포트 번호**가 다르기 때문에 서버는 이 4-tuple을 사용하여 각 클라이언트와의 연결에 해당하는 소켓을 구별합니다.

### III. UDP 특징 및 Checksum 해설

14. **UDP의 제어 우위:**
    *   **세그먼트에 담을 데이터 (What data is sent):** TCP는 신뢰적인 전송을 위해 데이터를 세그먼트로 나누고 관리하지만, UDP는 "bare bones" 프로토콜로, 애플리케이션 계층 메시지를 받아서 그대로 캡슐화하므로, 애플리케이션 개발자가 세그먼트에 담을 데이터에 대해 더 세밀한 제어를 할 수 있습니다 [17, 19, 86a].
    *   **세그먼트 전송 시점 (When segment is sent):** UDP는 **혼잡 제어(congestion control)**를 수행하지 않으므로, 애플리케이션은 원하는 만큼 빠르게 데이터를 "blast away" 할 수 있습니다. TCP는 혼잡 제어 및 흐름 제어로 인해 전송 시점을 조정해야 합니다 [15, 87b].

15. **UDP 상의 신뢰적 전송:**
    *   **가능합니다.** 애플리케이션 개발자는 신뢰성을 확보하기 위해 필요한 기능(예: 오류 복구, 시퀀스 번호, ACK, 타임아웃/재전송)을 **애플리케이션 계층**에 직접 추가하여 구현해야 합니다 [18, 78 R3].

16. **UDP 데이터그램 형식의 4개 헤더 필드:**
    1.  Source Port Number (출발지 포트 번호)
    2.  Destination Port Number (목적지 포트 번호)
    3.  Length (UDP 데이터그램의 바이트 길이, 헤더 포함)
    4.  Checksum (체크섬)

17. **Internet Checksum:**
    *   **송신자 계산 방법:** 세그먼트의 내용(헤더 필드와 애플리케이션 메시지 페이로드 포함)을 16비트 정수의 시퀀스로 취급하고, 이 내용들의 **1의 보수 합(one’s complement sum)**을 계산합니다. 송신자는 이 결과 값(1의 보수)을 체크섬 필드에 넣습니다.
    *   **오류 확신 불가 이유:** 체크섬은 단지 오류를 감지하는 것을 목표로 합니다. 수신자가 계산한 체크섬이 수신된 값과 일치하더라도, 세그먼트 내에서 비트 오류가 발생했지만 이 오류들이 합산 과정에서 서로 상쇄되어 (예: 0이 1로 바뀐 비트와 1이 0으로 바뀐 비트가 동시에 발생) 최종 1의 보수 합이 원래 값과 동일하게 나올 수 있기 때문에, 오류가 발생하지 않았다고 **절대적으로 확신할 수는 없습니다** [21, 85 P2].

18. **Internet Checksum의 Carry out 처리:**
    *   1의 보수 합을 계산할 때 가장 왼쪽 비트에서 **carry out (올림)**이 발생하면, 그 올림을 결과 값에 **1을 더하는 방식으로 처리**해야 합니다 (end-around carry).

### IV. TCP RDT 및 Flow Control 해설

19. **Sequence Number와 Acknowledgement의 역할:**
    *   **Sequence Number (순서 번호):** 송신자로부터 수신자로 흐르는 데이터 패킷의 순차적인 번호를 매기는 데 사용됩니다. TCP에서 순서 번호는 세그먼트의 첫 번째 데이터 바이트를 기준으로 합니다. 수신자는 이 번호를 통해 손실된 패킷(순서 번호의 간격)이나 중복된 패킷을 감지합니다.
    *   **Acknowledgement Number (확인 번호):** 수신자가 송신자에게 **다음에 기대하는 바이트의 순서 번호**를 알려주는 데 사용됩니다. TCP는 **누적 ACK (cumulative ACK)** 방식을 사용합니다.

20. **재전송된 세그먼트의 SampleRTT 측정 회피 이유:**
    *   TCP는 재전송된 세그먼트를 사용하여 SampleRTT를 측정하는 것을 피합니다. 그 이유는 송신자가 현재 수신한 ACK가 원래 전송된 세그먼트에 대한 응답인지, 아니면 재전송된 세그먼트에 대한 응답인지 **구별할 수 없기 때문**입니다. 이로 인해 부정확한 RTT 추정값이 계산될 수 있습니다.

21. **EstimatedRTT 계산 공식 및 $\alpha$ 값:**
    *   공식: $EstimatedRTT = (1-\alpha) \times EstimatedRTT + \alpha \times SampleRTT$.
    *   일반적인 $\alpha$ 값은 **0.125**입니다.

22. **Timeout Interval 계산 공식:**
    *   $TimeoutInterval$은 $EstimatedRTT$와 안전 마진($4 \times DevRTT$)을 더하여 계산됩니다.
    *   공식: $TimeoutInterval = EstimatedRTT + 4 \times DevRTT$.
    *   여기서 $DevRTT$는 $DevRTT = (1-\beta) \times DevRTT + \beta \times |SampleRTT-EstimatedRTT|$ 공식을 통해 계산됩니다 ($\beta$는 일반적으로 0.25).

23. **TCP Sequence/ACK Number 계산:**
    *   **S2의 Sequence Number:** Host B는 126번 바이트까지 수신했습니다. S1은 Seq=127, 80바이트입니다 (127~206 바이트). 따라서 S2는 207번 바이트부터 시작합니다. **Sequence Number = 207** [88a].
    *   **S2가 먼저 도착했을 경우 B의 ACK Number:** Host B는 127번 바이트부터 기대하고 있습니다. S2(Seq=207)가 먼저 도착하면 순서가 맞지 않는(out-of-order) 세그먼트로 간주되어 간격(Gap)이 감지됩니다. 이 경우 B는 **Sequence Number 127**을 가리키는 중복 ACK를 즉시 전송합니다. 이는 다음에 기대하는 바이트가 127번부터임을 나타냅니다 [42, 89c].

24. **TCP Flow Control 목적 및 rwnd:**
    *   **목적:** 수신자가 너무 많은 데이터 또는 너무 빠른 속도로 데이터를 전송받아 수신 버퍼(Receiver's Buffer)가 넘치는 것(overflow)을 방지하여 수신자를 압도하지 않도록 송신자의 전송 속도를 제어하는 것입니다.
    *   **rwnd (Receive Window):** 수신자의 TCP 소켓 버퍼에서 **현재 사용 가능한 여유 공간(free buffer space)**의 바이트 수입니다. 이 값은 수신자로부터 송신자에게 보내는 TCP 세그먼트의 헤더에 포함되어 광고됩니다.

25. **TCP Flow Control의 영향:**
    *   Host A의 전송 능력(120 Mbps)이 Host B의 데이터 처리 능력(50 Mbps)보다 훨씬 빠릅니다. TCP Flow Control이 없다면 Host B의 수신 버퍼가 오버플로우될 것입니다.
    *   Flow Control 덕분에, Host B는 $rwnd$를 통해 수신 버퍼의 남은 공간을 A에게 광고하고, A는 이 $rwnd$를 초과하여 데이터를 전송하지 않도록 제한됩니다. 궁극적으로 A의 전송 속도는 B가 데이터를 읽어내는 최대 속도인 **50 Mbps**로 제한됩니다.

26. **TCP Fast Retransmit 메커니즘:**
    *   TCP Fast Retransmit은 **타임아웃(timeout)** 기간이 상대적으로 길어 발생하는 지연을 줄이기 위해 사용됩니다.
    *   송신자가 동일한 데이터에 대한 ACK를 **세 번 추가적으로 (Triple Duplicate ACKs)** 수신했을 때, 송신자는 타임아웃을 기다리지 않고 즉시 가장 작은 순서 번호를 가진(가장 오래된) 아직 확인되지 않은(unACKed) 세그먼트를 재전송합니다.

### V. TCP Congestion Control 해설

27. **혼잡(Congestion)의 두 가지 주요 징후:**
    1.  **긴 지연 시간 (Long delays):** 라우터 버퍼 내에서의 큐잉(queueing)으로 인해 발생합니다.
    2.  **패킷 손실 (Lost packets):** 라우터에서의 버퍼 오버플로우로 인해 발생합니다.

28. **TCP의 혼잡 추론 및 전송률 변화:**
    *   TCP는 네트워크로부터 명시적인 피드백을 받지 않으며, 혼잡은 일반적으로 **손실 이벤트 (loss event)**를 통해 추론됩니다 (Timeout 또는 3 Duplicate ACKs).
    *   혼잡이 감지되면 (세그먼트 손실 시), TCP 송신자의 전송률(Congestion Window Size, $cwnd$)은 **감소**합니다.

29. **AIMD와 전송률 조정:**
    *   TCP는 **AIMD (Additive Increase, Multiplicative Decrease)** 방식을 사용합니다.
    *   **Additive Increase (AI):** 손실이 감지될 때까지 사용 가능한 대역폭을 찾기 위해 $cwnd$를 RTT당 **1 MSS**씩 점진적으로 선형 증가시킵니다.
    *   **Multiplicative Decrease (MD):** 손실 이벤트(혼잡) 발생 시, 전송률(즉, $cwnd$)을 **절반**으로 줄여(cut in half) 혼잡으로부터 빠르게 물러납니다.
    *   이 패턴이 반복되어 대역폭을 찾기 위해 **톱니 모양(sawtooth behavior)**으로 $cwnd$가 변화합니다.

30. **Slow Start (SS) 단계의 $cwnd$ 증가 방식:**
    *   Slow Start 단계는 연결 시작 시 $cwnd$를 **1 MSS**로 설정하는 것부터 시작합니다.
    *   $cwnd$는 RTT당 지수적으로 증가합니다. 구체적으로, **ACK가 수신될 때마다 $cwnd$를 1 MSS씩 증가시킵니다**. 이는 매 RTT마다 $cwnd$가 두 배로 증가하는 효과를 낳습니다.

31. **Slow Start 종료 및 Congestion Avoidance 전환 임계값 (ssthresh):**
    *   $cwnd$가 **ssthresh** 값에 도달하면 지수적 증가(SS)에서 선형적 증가(CA)로 전환됩니다.
    *   **ssthresh**는 이전 손실 이벤트 직전 $cwnd$ 값의 **절반(1/2)**으로 설정됩니다.

32. **TCP Tahoe와 TCP Reno의 Timeout 시 설정:**
    *   손실이 **Timeout**으로 감지되었을 경우, TCP Tahoe와 TCP Reno **모두** 다음 설정을 따릅니다:
        1.  $ssthresh \leftarrow cwnd / 2$
        2.  $cwnd \leftarrow 1$ (Slow Start 상태로 진입)

33. **TCP Reno의 Triple Duplicate ACK 시 설정:**
    *   TCP Reno에서 손실이 **Triple Duplicate ACK**로 감지되었을 경우:
        1.  $ssthresh \leftarrow cwnd / 2$
        2.  $cwnd \leftarrow ssthresh$ ($cwnd$를 즉시 절반으로 줄입니다. $cwnd / 2$)
        3.  송신자는 **Congestion Avoidance (CA)** 상태로 진입합니다 (선형적으로 $cwnd$를 증가시키기 시작합니다).

34. **AIMD의 공평한 대역폭 공유 (Equal RTT):**
    *   두 연결이 동일한 RTT를 가지고 혼잡 회피 단계에 있다면, AIMD 덕분에 대역폭을 공평하게 공유합니다. 두 연결은 $cwnd$를 동일한 속도로 증가시키다가 혼잡이 발생하면 $cwnd$를 동시에 절반으로 줄입니다 (Multiplicative Decrease). 이 움직임(Sawtooth)은 두 연결의 처리량이 $R/2$ 주변에서 동일하게 유지되도록 합니다 [70, 98b].

35. **AIMD의 불공평한 대역폭 공유 (Unequal RTT):**
    *   **No**. 두 연결이 서로 다른 RTT를 가질 경우, RTT가 더 짧은 연결(C1, 50msec)이 RTT가 긴 연결(C2, 100msec)보다 ACK를 더 자주 수신합니다. $cwnd$는 ACK를 받을 때마다 증가하기 때문에, RTT가 짧은 연결이 RTT가 긴 연결보다 더 빠르게 $cwnd$를 키울 수 있고, 장기적으로 병목 링크의 대역폭을 더 많이 차지하게 됩니다.

36. **TCP CUBIC의 $cwnd$ 증가 속도 변화:**
    *   CUBIC은 $W_{max}$ (이전 손실이 감지된 창 크기)에 가까워지는 것을 목표로 합니다.
    *   $W_{max}$에서 멀리 떨어져 있을 때는 $cwnd$ 증가 속도를 **더 빠르게** 하여 $W_{max}$에 도달하려고 시도합니다.
    *   $W_{max}$에 가까워질수록 $cwnd$ 증가 속도를 **더 느리게 (조심스럽게)** 변화시킵니다.

### VI. 계산 및 분석 문제 해설

37. **TCP RTT 추정 계산 ( $\alpha = 0.125$, $\beta = 0.25$):**
    *   공식: $EstimatedRTT = (1-\alpha) \times EstimatedRTT + \alpha \times SampleRTT$
    *   공식: $DevRTT = (1-\beta) \times DevRTT + \beta \times |SampleRTT - EstimatedRTT|$
    *   공식: $TimeoutInterval = EstimatedRTT + 4 \times DevRTT$

| Sample No. | SampleRTT (ms) | EstimatedRTT (ms) | DevRTT (ms) | TimeoutInterval (ms) |
| :---: | :---: | :---: | :---: | :---: |
| 초기 값 | - | 100 | 5 | 120 |
| 1 | 106 | **100.75** | **5.0625** | **121.0** |
| 2 | 120 | **103.15625** | **8.0078125** | **135.1875** |

**계산 과정:**
*   **Sample 1 (SampleRTT = 106):**
    *   EstimatedRTT = $(0.875 \times 100) + (0.125 \times 106) = 87.5 + 13.25 = 100.75$
    *   Deviation = $|106 - 100.75| = 5.25$
    *   DevRTT = $(0.75 \times 5) + (0.25 \times 5.25) = 3.75 + 1.3125 = 5.0625$
    *   TimeoutInterval = $100.75 + (4 \times 5.0625) = 100.75 + 20.25 = 121.0$
*   **Sample 2 (SampleRTT = 120):**
    *   EstimatedRTT = $(0.875 \times 100.75) + (0.125 \times 120) \approx 88.156 + 15 = 103.15625$
    *   Deviation = $|120 - 103.15625| \approx 16.84375$
    *   DevRTT = $(0.75 \times 5.0625) + (0.25 \times 16.84375) \approx 3.796 + 4.210 = 8.0078125$
    *   TimeoutInterval = $103.15625 + (4 \times 8.0078125) \approx 103.15625 + 32.03125 = 135.1875$

38. **TCP Congestion Control (AIMD/Slow Start 분석):** (P15 그림 데이터 기반)

| Transmission Round | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| $cwnd$ (MSS) | 1 | 2 | 4 | 8 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 12 | 13 | 14 |

*   **a. Slow Start (SS) 구간:** $cwnd$가 RTT당 지수적으로 증가합니다 (1, 2, 4, 8, 16).
    *   **Transmission Round 1, 2, 3, 4, 5**.
*   **b. Congestion Avoidance (CA) 구간:** $cwnd$가 RTT당 1 MSS씩 선형적으로 증가합니다 (17, 18, 19, ..., 24).
    *   **Transmission Round 6 through 13**.
*   **c. 손실 감지 방식 (Round 13 -> 14):** $cwnd$가 24에서 12로 정확히 **절반**으로 줄었으며 (MD), $cwnd$가 1 MSS로 떨어지지 않았습니다. 이는 **Triple Duplicate ACK**로 손실이 감지되었음을 의미합니다 (TCP Reno).
*   **d. 14번째 Transmission Round 직전 ssthresh 값:** Triple Duplicate ACK가 발생했을 때 $ssthresh$는 손실 직전 $cwnd$의 절반으로 설정됩니다. $ssthresh = 24 / 2 = **12**$ MSS.