\documentclass[a4paper, 10pt]{article}

% pdfLaTeX용 한글 패키지
\usepackage{kotex}

% 기본 패키지
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{array}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=blue]{hyperref}

% 페이지 여백 설정
\geometry{
  top=2.5cm,
  bottom=2.5cm,
  left=2cm,
  right=2cm,
  headheight=20pt
}

% 머리글 및 바닥글 설정 (해설지용으로 수정)
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.8pt}
\renewcommand{\footrulewidth}{0.4pt}
\lhead{\small 2025학년도 중간고사 대비 연습문제}
\chead{\small\textbf{컴퓨터 네트워크 - 정답 및 해설}}
\rhead{\small\thepage}
\cfoot{\scriptsize ※ 본 해설지는 학습 목적으로 제작되었습니다.}

% 원형 숫자
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
  \node[shape=circle,draw,inner sep=0.7pt,minimum size=0.7em,line width=0.5pt] (char) {\small #1};}}

% 객관식 문항 스타일
\newlist{mchoice}{enumerate}{1}
\setlist[mchoice,1]{
  label=\protect\circled{\arabic*},
  leftmargin=2em,
  itemsep=0.3em,
  parsep=0pt
}

% 커스텀 명령어
\newcommand{\sectionbox}[1]{
  \vspace{0.5em}
  \noindent\fbox{\textbf{#1}}
  \vspace{0.5em}
}

\setlength{\parindent}{0pt}

\begin{document}

\begin{center}
  \Large\textbf{2025학년도 컴퓨터네트워크 midterm 대비 연습문제 정답 및 해설}\\[8pt]
  \large\textbf{Chapter 3. Transport Layer}\\[5pt]
  \small\textbf{contact: \href{mailto:wrim0923@ewhain.net}{wrim0923@ewhain.net} | github: \href{https://github.com/RainyForest23}{RainyForest23}}\\[5pt]
  \small\textcolor{gray}{Last updated: \today}
\end{center}

\vspace{1cm}

% --- 빠른 정답 ---
\section*{빠른 정답}
\noindent\rule{\textwidth}{0.6pt}
\begin{center}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{*{5}{p{0.19\textwidth}}}
\toprule
\textbf{1.} (해설 참조) & \textbf{2.} 호스트 & \textbf{3.} TCP/UDP & \textbf{4.} (해설 참조) & \textbf{5.} False \\
\textbf{6.} True & \textbf{7.} UDP, (해설 참조) & \textbf{8.} Application & \textbf{9.} 포트 번호 & \textbf{10.} (해설 참조) \\
\textbf{11.} 목적지 포트 & \textbf{12.} 4-tuple & \textbf{13.} (해설 참조) & \textbf{14.} (해설 참조) & \textbf{15.} Application \\
\textbf{16.} (해설 참조) & \textbf{17.} (해설 참조) & \textbf{18.} wraparound & \textbf{19.} (해설 참조) & \textbf{20.} (해설 참조) \\
\textbf{21.} (해설 참조) & \textbf{22.} (해설 참조) & \textbf{23.} 207, 127 & \textbf{24.} (해설 참조) & \textbf{25.} (해설 참조) \\
\textbf{26.} 3 dup ACK & \textbf{27.} (해설 참조) & \textbf{28.} (해설 참조) & \textbf{29.} AIMD & \textbf{30.} (해설 참조) \\
\textbf{31.} (해설 참조) & \textbf{32.} cwnd/2, 1 & \textbf{33.} (해설 참조) & \textbf{34.} (해설 참조) & \textbf{35.} No \\
\textbf{36.} (해설 참조) & \textbf{37.} (계산 참조) & \textbf{38.} (계산 참조) &  &  \\
\bottomrule
\end{tabular}
\end{center}

\newpage

% --- 상세 해설 ---
\section*{상세 해설}
\noindent\rule{\textwidth}{0.8pt}

\begin{enumerate}[itemsep=2.5em, leftmargin=2em, label={}]

\item[] \sectionbox{I. 용어 및 기본 개념 (8문제)}

\item[\textbf{1.}] Transport Layer의 주요 목표(goals) 5가지를 나열하시오.
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{enumerate}[itemsep=0.3em]
    \item Multiplexing (다중화) 및 Demultiplexing (역다중화)
    \item Reliable Data Transfer (신뢰할 수 있는 데이터 전송)
    \item Flow Control (흐름 제어)
    \item Congestion Control (혼잡 제어)
    \item End-to-end error detection (종단 간 오류 감지)
\end{enumerate}

\small\textbf{해설:} Transport Layer는 서로 다른 호스트에서 실행되는 애플리케이션 프로세스 간의 논리적 통신을 제공합니다. TCP의 경우 위의 모든 기능을 제공하지만, UDP는 기본적인 다중화/역다중화와 에러 체크만 제공합니다.

\item[\textbf{2.}] Network Layer는 무엇 간의 논리적 통신을 제공하는가?
\vspace{0.5em}

\noindent\textbf{정답:} 호스트 (hosts)

\small\textbf{해설:} Transport Layer는 프로세스 간의 논리적 통신을 제공하는 반면, Network Layer(IP)는 호스트 간의 논리적 통신을 제공합니다.

\item[\textbf{3.}] TCP와 UDP의 풀네임과 특징 비교
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item TCP: Transmission Control Protocol / 연결 지향 / 신뢰성 있음
    \item UDP: User Datagram Protocol / 비연결 / 신뢰성 없음
\end{itemize}

\small\textbf{해설:} TCP는 연결 설정, 신뢰성 있는 전송, 흐름 제어, 혼잡 제어를 제공하는 반면, UDP는 최소한의 서비스만 제공하여 빠르고 오버헤드가 적습니다.

\item[\textbf{4.}] TCP의 세그먼트 송수신 과정
\vspace{0.5em}

\noindent\textbf{정답:} 송신자 측에서는 Application Layer의 메시지를 여러 개의 세그먼트(segments)로 나누어 Transport Header를 추가한 후 IP 계층(Network Layer)으로 전달합니다. 수신자 측에서는 세그먼트를 수신하고 헤더 값을 확인하여 세그먼트들을 재조립(reassembles)하여 메시지를 애플리케이션 계층으로 전달합니다.

\item[\textbf{5.}] ACK 전송 관련 True/False
\vspace{0.5em}

\noindent\textbf{정답:} False

\small\textbf{해설:} Host B가 보낼 데이터가 없더라도 Host A가 보낸 데이터의 수신 확인(ACK)을 독립적인 세그먼트로 보내야 합니다. TCP는 신뢰적인 전송을 위해 ACK에 의존하며, 피기백이 불가능한 경우에도 ACK를 전송해야 합니다.

\item[\textbf{6.}] Unacknowledged bytes와 RcvBuffer 관계
\vspace{0.5em}

\noindent\textbf{정답:} True

\small\textbf{해설:} Host A가 보낼 수 있는 unacknowledged bytes의 수는 수신자가 광고하는 rwnd(receive window) 값에 의해 제한됩니다. rwnd는 수신 버퍼의 여유 공간을 나타내므로, rwnd를 따르는 한 수신 버퍼 오버플로우를 방지할 수 있습니다.

\item[\textbf{7.}] QUIC의 동작 계층과 이점
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 동작 계층: UDP 위에서 동작 (Application Layer에서 구현)
    \item 주요 이점: TCP handshake와 TLS handshake를 통합하여 연결 설정 시간을 단축합니다. 0-RTT 또는 1-RTT로 연결을 설정할 수 있습니다.
\end{itemize}

\small\textbf{해설:} TCP는 두 번의 직렬 핸드셰이크를 필요로 하는 반면, QUIC은 모든 기능을 하나의 핸드셰이크로 완료하여 지연 시간을 줄입니다.

\item[\textbf{8.}] QUIC의 기능 구현 위치
\vspace{0.5em}

\noindent\textbf{정답:} Application Layer (애플리케이션 계층 또는 사용자 공간)

\small\textbf{해설:} QUIC은 UDP 위에서 동작하지만 신뢰성, 혼잡 제어 등의 기능을 Application Layer에서 직접 구현합니다. 이를 통해 OS 커널 수정 없이 빠른 프로토콜 개선이 가능합니다.


\item[] \sectionbox{II. Mux/Demux 및 Socket (5문제)}

\item[\textbf{9.}] Multiplexing과 Transport Header
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 추가 정보: Source Port Number (출발지 포트 번호)와 Destination Port Number (목적지 포트 번호)
    \item 역할: 수신자 측에서 올바른 프로세스/소켓으로 데이터를 전달하기 위한 Demultiplexing에 사용됩니다.
\end{itemize}

\item[\textbf{10.}] 세그먼트를 올바른 소켓으로 전달하는 방법
\vspace{0.5em}

\noindent\textbf{정답:} IP 데이터그램의 Source/Destination IP Address와 세그먼트 헤더의 Source/Destination Port Number를 사용하여 해당 소켓을 식별하고 데이터를 전달합니다. TCP의 경우 4-tuple을 모두 사용합니다.

\item[\textbf{11.}] UDP Demultiplexing
\vspace{0.5em}

\noindent\textbf{정답:} Destination Port Number (목적지 포트 번호)

\small\textbf{해설:} UDP는 주로 목적지 포트 번호를 확인하여 올바른 소켓으로 데이터그램을 전달합니다. 동일한 목적지 포트 번호를 가지는 UDP 데이터그램은 출발지 정보가 달라도 동일한 소켓으로 전달됩니다.

\item[\textbf{12.}] TCP Demultiplexing의 4-tuple
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{enumerate}[itemsep=0.3em]
    \item Source IP Address (출발지 IP 주소)
    \item Source Port Number (출발지 포트 번호)
    \item Destination IP Address (목적지 IP 주소)
    \item Destination Port Number (목적지 포트 번호)
\end{enumerate}

\small\textbf{해설:} TCP는 연결 지향 프로토콜이므로 각 연결을 고유하게 식별하기 위해 4-tuple을 사용합니다.

\item[\textbf{13.}] 웹 서버의 TCP 소켓 식별
\vspace{0.5em}

\noindent\textbf{정답:} 각 TCP 소켓은 4-tuple (출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트)로 고유하게 식별됩니다. 서버는 동일한 포트를 사용하더라도 클라이언트마다 서로 다른 출발지 IP와 포트를 가지므로 각 연결을 구분할 수 있습니다.


\item[] \sectionbox{III. UDP 특징 및 Checksum (5문제)}

\item[\textbf{14.}] UDP의 세밀한 제어
\vspace{0.5em}

\noindent\textbf{정답:} UDP는 혼잡 제어나 재전송 메커니즘이 없으므로 애플리케이션이 소켓에 데이터를 쓰는 즉시 전송됩니다. TCP는 세그먼트를 나누고 관리하지만, UDP는 애플리케이션 계층 메시지를 그대로 캡슐화하므로 데이터와 전송 시점에 대한 더 세밀한 제어가 가능합니다.

\item[\textbf{15.}] UDP에서 신뢰성 추가
\vspace{0.5em}

\noindent\textbf{정답:} Application Layer (애플리케이션 계층)

\small\textbf{해설:} UDP는 신뢰성을 제공하지 않지만, 필요한 경우 애플리케이션 개발자가 Application Layer에서 ACK, 재전송, 타임아웃 등의 메커니즘을 직접 구현할 수 있습니다.

\item[\textbf{16.}] UDP 헤더의 4개 필드
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{enumerate}[itemsep=0.3em]
    \item Source Port Number (출발지 포트 번호)
    \item Destination Port Number (목적지 포트 번호)
    \item Length (길이)
    \item Checksum (체크섬)
\end{enumerate}

\small\textbf{해설:} UDP 헤더는 각 필드가 16비트(2바이트)로 총 8바이트입니다.

\item[\textbf{17.}] Internet Checksum
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 계산 방법: 세그먼트 내용을 16비트 정수의 시퀀스로 취급하고 1의 보수 합(one's complement sum)을 계산한 후, 그 결과의 1의 보수를 취합니다.
    \item 확신할 수 없는 이유: 여러 비트가 변경되어 오류들이 서로 상쇄되면 checksum이 우연히 같은 값이 될 수 있습니다. Checksum은 단순한 오류 검출 메커니즘이므로 모든 오류를 감지하지 못합니다.
\end{itemize}

\item[\textbf{18.}] Checksum의 carry out 처리
\vspace{0.5em}

\noindent\textbf{정답:} Carry out이 발생하면 이를 결과 값에 1을 더하는 방식으로 처리합니다 (end-around carry, wraparound).


\item[] \sectionbox{IV. TCP RDT 및 Flow Control (8문제)}

\item[\textbf{19.}] Sequence Number와 Acknowledgement의 역할
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item Sequence Number: 세그먼트의 첫 번째 바이트가 전체 데이터 스트림에서 몇 번째 바이트인지를 나타냅니다. 수신자가 순서대로 재조립하고 손실/중복 패킷을 감지하는 데 사용됩니다.
    \item Acknowledgement: 수신자가 다음에 받기를 기대하는 바이트 번호를 나타냅니다. 누적 확인응답(cumulative ACK) 방식으로 해당 번호 이전의 모든 바이트를 성공적으로 수신했음을 의미합니다.
\end{itemize}

\item[\textbf{20.}] 재전송 세그먼트로 RTT를 측정하지 않는 이유
\vspace{0.5em}

\noindent\textbf{정답:} 재전송된 세그먼트에 대한 ACK가 도착했을 때, 이것이 원래 전송에 대한 응답인지 재전송에 대한 응답인지 구분할 수 없기 때문입니다 (retransmission ambiguity problem). 이로 인해 부정확한 RTT 추정값이 계산될 수 있습니다.

\item[\textbf{21.}] EstimatedRTT 계산 공식
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 공식: EstimatedRTT = $(1-\alpha) \times \text{EstimatedRTT} + \alpha \times \text{SampleRTT}$
    \item $\alpha$의 값: 0.125 (일반적으로 1/8)
\end{itemize}

\small\textbf{해설:} EWMA(Exponential Weighted Moving Average)를 사용하여 과거 값에 더 큰 가중치를 두고 최근 측정값을 반영합니다.

\item[\textbf{22.}] Timeout Interval 계산 공식
\vspace{0.5em}

\noindent\textbf{정답:} TimeoutInterval = $\text{EstimatedRTT} + 4 \times \text{DevRTT}$

\small\textbf{해설:} DevRTT는 RTT의 변동성을 나타내며, $\beta = 0.25$를 사용하여 계산됩니다:

DevRTT = $(1-\beta) \times \text{DevRTT} + \beta \times |\text{SampleRTT} - \text{EstimatedRTT}|$

\item[\textbf{23.}] TCP Sequence Number와 ACK 계산
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item S2의 Sequence Number: 207 (= 127 + 80)
    \item S2 수신 후 B가 보내는 ACK: 127 (S1을 기다리고 있음)
\end{itemize}

\small\textbf{해설:} TCP는 순서가 맞지 않는 세그먼트를 받으면 중복 ACK를 보냅니다. B는 아직 127번부터 시작하는 데이터를 받지 못했으므로 ACK=127을 보냅니다.

\item[\textbf{24.}] TCP Flow Control의 목적과 rwnd
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 목적: 송신자가 수신자의 버퍼를 오버플로우시키지 않도록 전송 속도를 조절하는 것
    \item rwnd: 수신자의 수신 버퍼에서 현재 사용 가능한 여유 공간의 크기(바이트 단위)
\end{itemize}

\item[\textbf{25.}] Flow Control의 작동
\vspace{0.5em}

\noindent\textbf{정답:} Host A의 전송 능력(120 Mbps)이 Host B의 데이터 처리 능력(50 Mbps)보다 빠릅니다. Flow Control 덕분에 B는 rwnd를 통해 수신 버퍼의 남은 공간을 A에게 광고하고, A는 이 rwnd를 초과하여 데이터를 전송하지 않도록 제한됩니다. 궁극적으로 전송 속도는 B가 데이터를 읽어내는 최대 속도인 50 Mbps로 제한됩니다.

\item[\textbf{26.}] TCP Fast Retransmit
\vspace{0.5em}

\noindent\textbf{정답:} 송신자가 동일한 ACK를 3번 중복으로 받으면(Triple Duplicate ACKs), 타임아웃을 기다리지 않고 해당 세그먼트를 즉시 재전송합니다.

\small\textbf{해설:} 이를 통해 패킷 손실을 빠르게 감지하고 복구할 수 있습니다.


\item[] \sectionbox{V. TCP Congestion Control (12문제)}

\item[\textbf{27.}] 혼잡의 두 가지 징후
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 긴 지연 시간 (Long delays) - 라우터 버퍼 내 큐잉으로 인한 발생
    \item 패킷 손실 (Lost packets) - 버퍼 오버플로우로 인한 발생
\end{itemize}

\item[\textbf{28.}] TCP의 혼잡 감지와 cwnd 변화
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item Loss event: 타임아웃(Timeout) 또는 3 duplicate ACKs
    \item cwnd 변화: 감소합니다. 타임아웃 시 1 MSS로, 3 duplicate ACKs 시 절반으로 감소합니다.
\end{itemize}

\item[\textbf{29.}] AIMD와 TCP
\vspace{0.5em}

\noindent\textbf{정답:} AIMD (Additive Increase Multiplicative Decrease)는 손실이 감지될 때까지 cwnd를 RTT당 1 MSS씩 점진적으로 선형 증가시키고(Additive Increase), 손실 이벤트 발생 시 cwnd를 절반으로 줄이는(Multiplicative Decrease) 방식입니다. 이 패턴이 반복되어 톱니 모양(sawtooth behavior)으로 cwnd가 변화하며 대역폭을 공정하게 공유합니다.

\item[\textbf{30.}] Slow Start의 cwnd 증가 방식
\vspace{0.5em}

\noindent\textbf{정답:} Slow Start 단계에서는 연결 시작 시 cwnd를 1 MSS로 설정합니다. ACK를 받을 때마다 cwnd를 1 MSS씩 증가시킵니다. 따라서 RTT마다 cwnd가 2배로 증가하여 지수적 증가(exponential growth) 패턴을 보입니다. 예: 1 → 2 → 4 → 8 → 16 MSS

\item[\textbf{31.}] ssthresh 설정 시기와 값
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 언제: cwnd가 ssthresh에 도달하거나 혼잡(loss event)이 감지될 때
    \item 값: 혼잡 발생 시 이전 손실 이벤트 직전 cwnd 값의 절반(1/2)으로 설정됩니다.
\end{itemize}

\small\textbf{해설:} cwnd가 ssthresh에 도달하면 Slow Start에서 Congestion Avoidance로 전환됩니다.

\item[\textbf{32.}] TCP Tahoe/Reno의 Timeout 처리
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item ssthresh = cwnd / 2 (현재 cwnd의 절반)
    \item cwnd = 1 MSS
\end{itemize}

\small\textbf{해설:} Timeout은 심각한 혼잡 신호로 간주되어 cwnd를 1 MSS로 초기화하고 Slow Start를 다시 시작합니다.

\item[\textbf{33.}] TCP Reno의 Triple Duplicate ACK 처리
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item ssthresh = cwnd / 2
    \item cwnd = ssthresh (cwnd / 2)
    \item 진입 상태: Congestion Avoidance (CA)
\end{itemize}

\small\textbf{해설:} TCP Reno는 3 duplicate ACKs를 timeout보다 가벼운 혼잡 신호로 간주하여 cwnd를 절반으로만 줄이고 Congestion Avoidance 상태로 전환합니다.

\item[\textbf{34.}] AIMD와 공평성
\vspace{0.5em}

\noindent\textbf{정답:} 두 연결이 동일한 RTT를 가지면 AIMD 알고리즘에 의해 대역폭을 공평하게 나눕니다. Sawtooth 패턴에서 두 연결은 공평성 선을 향해 수렴합니다. Additive Increase 시 두 연결이 동시에 증가하고, 혼잡 발생 시 둘 다 절반으로 감소하여 장기적으로 R/2씩 사용하게 됩니다.

\item[\textbf{35.}] RTT가 다를 때의 공평성
\vspace{0.5em}

\noindent\textbf{정답:}
\begin{itemize}[itemsep=0.3em]
    \item 답: No (아니요)
    \item 이유: RTT가 짧은 C1(50msec)이 더 빨리 ACK를 받으므로 cwnd를 더 빠르게 증가시킵니다. cwnd는 ACK를 받을 때마다 증가하기 때문에 RTT가 짧은 연결이 더 많은 대역폭을 차지하게 됩니다.
\end{itemize}

\item[\textbf{36.}] TCP CUBIC의 cwnd 조정
\vspace{0.5em}

\noindent\textbf{정답:} CUBIC은 $W_{max}$ (이전 손실이 감지된 창 크기)에 가까워지는 것을 목표로 합니다. $W_{max}$에서 멀리 떨어져 있을 때는 cwnd 증가 속도를 더 빠르게 하여 $W_{max}$에 도달하려 하고, $W_{max}$에 가까워질수록 cwnd 증가 속도를 더 느리게(조심스럽게) 변화시킵니다. 이는 3차 함수(cubic function)를 사용하여 구현됩니다.


\item[] \sectionbox{VI. 계산 및 분석 문제 (2문제)}

\item[\textbf{37.}] \textbf{[TCP RTT 추정 계산]}
\vspace{0.5em}

\noindent\textbf{정답:}

\textbf{Sample 1 (SampleRTT = 106ms):}
\begin{itemize}[itemsep=0.2em]
    \item EstimatedRTT = $0.875 \times 100 + 0.125 \times 106 = 100.75$ ms
    \item Deviation = $|106 - 100.75| = 5.25$ ms
    \item DevRTT = $0.75 \times 5 + 0.25 \times 5.25 = 5.0625$ ms
    \item TimeoutInterval = $100.75 + 4 \times 5.0625 = 121.0$ ms
\end{itemize}

\textbf{Sample 2 (SampleRTT = 120ms):}
\begin{itemize}[itemsep=0.2em]
    \item EstimatedRTT = $0.875 \times 100.75 + 0.125 \times 120 = 103.15625$ ms
    \item Deviation = $|120 - 103.15625| = 16.84375$ ms
    \item DevRTT = $0.75 \times 5.0625 + 0.25 \times 16.84375 = 8.0078125$ ms
    \item TimeoutInterval = $103.15625 + 4 \times 8.0078125 = 135.1875$ ms
\end{itemize}

\item[\textbf{38.}] \textbf{[TCP Congestion Control 분석]}
\vspace{0.5em}

\noindent\textbf{정답:}

\begin{enumerate}[label=\alph*., itemsep=0.3em]
    \item \textbf{Slow Start 구간:} Transmission Round 1, 2, 3, 4, 5

    cwnd가 지수적으로 증가 (1 → 2 → 4 → 8 → 16)

    \item \textbf{Congestion Avoidance 구간:} Transmission Round 6-13, 14-16

    cwnd가 선형적으로 증가 (16 → 17 → 18 → ... → 24, 12 → 13 → 14)

    \item \textbf{손실 감지 방식:} Triple Duplicate ACK

    \textbf{이유:} cwnd가 24에서 12로 정확히 절반으로 감소했습니다 (Multiplicative Decrease). Timeout이었다면 cwnd = 1 MSS로 감소했을 것입니다. 이는 TCP Reno의 Triple Duplicate ACK 처리 방식입니다.

    \item \textbf{ssthresh 값:} 12 MSS

    \textbf{이유:} Round 13의 cwnd = 24일 때 손실 발생, ssthresh = 24 / 2 = 12 MSS로 설정되었습니다.
\end{enumerate}

\small\textbf{해설:} 이 시나리오는 TCP Reno의 전형적인 동작을 보여줍니다. Slow Start로 빠르게 증가한 후 ssthresh(16)에 도달하면 Congestion Avoidance로 전환되어 선형 증가합니다. Triple duplicate ACK로 손실이 감지되면 cwnd를 절반으로 줄이고 Congestion Avoidance를 재개합니다.

\end{enumerate}

\vfill
\begin{center}
  \rule{0.9\textwidth}{0.4pt}\\[8pt]
  {\small\textbf{--- 공부하시느라 수고하셨습니다 ---}}\\[6pt]
  {\scriptsize ※ 본 해설지는 학습 목적으로 제작되었습니다.}
\end{center}

\end{document}
