\documentclass[a4paper, 10pt]{article}

% pdfLaTeX용 한글 패키지
\usepackage{kotex}

% 기본 패키지
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{array}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=blue]{hyperref} % 하이퍼링크 (가장 마지막에)

% 페이지 여백 설정
\geometry{
  top=2.5cm,
  bottom=2.5cm,
  left=2cm,
  right=2cm,
  headheight=20pt
}

% 머리글 및 바닥글 설정
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.8pt}
\renewcommand{\footrulewidth}{0.4pt}
\lhead{\small 2025학년도 중간고사 대비 연습문제}
\chead{\small\textbf{컴퓨터 네트워크}}
\rhead{\small\thepage}
\cfoot{\scriptsize ※ 모든 문제의 답은 지정된 곳에 정확히 기입하시오.}

% 원형 숫자
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
  \node[shape=circle,draw,inner sep=0.7pt,minimum size=0.7em,line width=0.5pt] (char) {\small #1};}}

% 객관식 문항 스타일
\newlist{mchoice}{enumerate}{1}
\setlist[mchoice,1]{
  label=\protect\circled{\arabic*},
  leftmargin=2em,
  itemsep=0.3em,
  parsep=0pt
}

% 커스텀 명령어
\newcommand{\ansline}[1]{\underline{\hspace{#1}}}
\newcommand{\sectionbox}[1]{
  \vspace{0.5em}
  \noindent\fbox{\textbf{#1}}
  \vspace{0.5em}
}

\setlength{\parindent}{0pt}

\begin{document}

% 시험지 제목 블록
\begin{center}
  \Large\textbf{2025학년도 컴퓨터네트워크 중간고사 대비 연습문제지}\\[8pt]
  \large\textbf{Chapter 3. Transport Layer}\\[5pt]
  \small\textbf{contact: \href{mailto:wrim0923@ewhain.net}{wrim0923@ewhain.net} | github: \href{https://github.com/RainyForest23}{RainyForest23}}\\[5pt]
  \small\textcolor{gray}{Last updated: \today}
\end{center}

\vspace{0.5cm}

% 수험 정보
\begin{tabular}{|m{0.48\textwidth}|m{0.48\textwidth}|}
\hline
\textbf{성명:} \hfill & \textbf{학번:} \hfill \\[0.8em]
\hline
\end{tabular}
\vspace{1em}

\noindent
{\small ※ 각 문항의 정답을 해당란에 정확히 기입하시오. (총 38문항)}

\vspace{0.5em}
\noindent\rule{\textwidth}{0.8pt}
\vspace{0.5em}

% 문제 시작
\begin{enumerate}[itemsep=2em, leftmargin=2em, label={}]

\item[] \sectionbox{I. 용어 및 기본 개념 (8문제)}

\item[\textbf{1.}] Transport Layer의 주요 목표(goals) 5가지를 나열하시오.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{5cm}
    \item \ansline{5cm}
    \item \ansline{5cm}
    \item \ansline{5cm}
    \item \ansline{5cm}
\end{enumerate}

\item[\textbf{2.}] Transport Layer와 Network Layer의 주요 기능 차이점을 설명하시오. 특히 Transport Layer는 프로세스 간의 논리적 통신(logical communication between processes)을 제공하는 반면, Network Layer는 무엇 간의 논리적 통신을 제공하는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item Network Layer는 \ansline{5cm} 간의 논리적 통신을 제공한다.
\end{enumerate}

\item[\textbf{3.}] 인터넷에서 주로 사용되는 두 가지 Transport Protocol인 TCP와 UDP의 이름(풀네임)과 각각의 주요 특징 (연결 지향/비연결, 신뢰성/비신뢰성)을 비교하여 설명하시오.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item TCP: \ansline{5cm} / 연결 지향 / 신뢰성 있음
    \item UDP: \ansline{5cm} / 비연결 / 신뢰성 없음
\end{enumerate}

\item[\textbf{4.}] TCP는 Application Layer 메시지를 여러 개의 segment로 나누어 Network Layer에 전달하고, 수신자 측에서는 이를 재조립하여 메시지를 Application Layer로 전달한다. 이와 같은 송수신 과정이 Transport Layer에서 어떻게 이루어지는지 설명하시오.
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{5.}] 다음 설명이 참(True)인지 거짓(False)인지 판단하고, 거짓이라면 이유를 설명하시오:
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item Host A가 TCP 연결을 통해 Host B에게 대용량 파일을 전송 중이고, Host B는 Host A에게 전송할 데이터가 없다. Host B는 데이터에 ACK를 피기백(piggyback)할 수 없으므로 ACK를 Host A에게 보내지 않을 것이다.
    \item 답: \ansline{2cm} / 이유: \ansline{10cm}
\end{enumerate}

\item[\textbf{6.}] 다음 설명이 참(True)인지 거짓(False)인지 판단하고, 거짓이라면 이유를 설명하시오:
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item Host A가 TCP 연결을 통해 Host B에게 대용량 파일을 전송 중이다. A가 보낼 수 있는 아직 ACK를 받지 못한 바이트의 수(unacknowledged bytes)는 수신 버퍼 크기($RcvBuffer$)를 초과할 수 없다.
    \item 답: \ansline{2cm} / 이유: \ansline{10cm}
\end{enumerate}

\item[\textbf{7.}] QUIC (Quick UDP Internet Connections)은 어떤 계층 위에서 동작하는 프로토콜이며, QUIC이 TCP에 비해 가지는 연결 설정상의 주요 이점(TCP handshake와 TLS handshake의 관점)은 무엇인가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item 동작 계층: \ansline{5cm}
    \item 주요 이점: \ansline{10cm}
\end{enumerate}

\item[\textbf{8.}] QUIC은 UDP 상에서 구현되었음에도 불구하고, 신뢰할 수 있는 데이터 전송 (reliable data transfer), 혼잡 제어 (congestion control) 등 TCP와 유사한 기능을 제공한다. 이는 QUIC이 이러한 기능을 어디에서 구현하기 때문인가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{6cm}
\end{enumerate}


\item[] \sectionbox{II. Mux/Demux 및 Socket (5문제)}

\item[\textbf{9.}] Multiplexing은 송신자(Sender)가 다수의 소켓으로부터 데이터를 처리하는 기능이다. 이때 Transport Header에 추가하는 정보는 무엇이며, 이 정보의 역할은 무엇인가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item 추가 정보: \ansline{5cm}
    \item 역할: \ansline{8cm}
\end{enumerate}

\item[\textbf{10.}] 수신 호스트가 IP 데이터그램을 수신하면, 이 데이터그램이 Transport Layer 세그먼트를 전달하고 있음을 알 수 있다. 호스트는 이 세그먼트를 올바른 소켓으로 전달하기 위해 IP 계층 정보와 Transport 계층 정보를 어떻게 활용하는가?
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{11.}] Connectionless (UDP) Demultiplexing 시, 수신 호스트는 어떤 정보를 기반으로 수신된 UDP 데이터그램을 올바른 소켓으로 전달하는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{7cm}
\end{enumerate}

\item[\textbf{12.}] Connection-oriented (TCP) Demultiplexing 시, 수신 호스트는 어떤 4가지 정보를 기반으로 수신된 TCP 세그먼트를 올바른 소켓으로 전달하는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{4cm}
    \item \ansline{4cm}
    \item \ansline{4cm}
    \item \ansline{4cm}
\end{enumerate}

\item[\textbf{13.}] 웹 서버가 다수의 클라이언트와 동시에 TCP 소켓을 통해 통신할 때, 각 클라이언트와의 연결을 위해 서버 호스트는 여러 개의 TCP 소켓을 지원할 수 있다. 이때 각 소켓은 서버 측에서 어떻게 식별되는지 4가지 정보(4-tuple)를 기준으로 설명하시오.
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}


\item[] \sectionbox{III. UDP 특징 및 Checksum (5문제)}

\item[\textbf{14.}] 응용 프로그램이 TCP 대신 UDP를 선택할 경우, UDP는 TCP에 비해 세그먼트에 담을 데이터와 세그먼트 전송 시점에 대해 더 세밀한 제어(finer control)를 할 수 있다. 그 이유를 각각 설명하시오.
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{15.}] UDP는 비신뢰적(unreliable)이지만, UDP를 사용하는 응용 프로그램도 신뢰적인 데이터 전송(reliable data transfer)을 누릴 수 있다. 만약 가능하다면, 애플리케이션 개발자는 신뢰성을 어떤 계층에서 추가해야 하는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{6cm}
\end{enumerate}

\item[\textbf{16.}] UDP 데이터그램 형식에 포함되는 4개의 헤더 필드(32비트 단위)를 나열하시오.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{4cm}
    \item \ansline{4cm}
    \item \ansline{4cm}
    \item \ansline{4cm}
\end{enumerate}

\item[\textbf{17.}] TCP와 UDP는 모두 Internet Checksum을 사용하여 전송된 세그먼트에서 비트 오류를 감지하는 것을 목표로 한다.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item 송신자가 체크섬을 계산하는 방법(주요 연산)을 설명하시오: \ansline{8cm}
    \item 수신자가 계산한 체크섬이 수신된 세그먼트의 체크섬 필드 값과 일치하더라도, 수신자는 오류가 발생하지 않았다고 절대적으로 확신할 수 없는 이유를 설명하시오: \ansline{8cm}
\end{enumerate}

\item[\textbf{18.}] Internet Checksum 계산 과정에서, 1의 보수 합(one's complement sum)을 계산할 때 발생하는 carry out (올림)은 어떻게 처리되어야 하는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{8cm}
\end{enumerate}


\item[] \sectionbox{IV. TCP RDT 및 Flow Control (8문제)}

\item[\textbf{19.}] 신뢰할 수 있는 데이터 전송 (rdt) 프로토콜 구현에 사용되는 주요 메커니즘인 Sequence Number와 Acknowledgement의 역할에 대해 설명하시오.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item Sequence Number: \ansline{8cm}
    \item Acknowledgement: \ansline{8cm}
\end{enumerate}

\item[\textbf{20.}] TCP RTT(Round Trip Time)를 측정하는 SampleRTT는 재전송된 세그먼트를 이용하여 측정하는 것을 피한다. 그 이유는 무엇인가?
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{21.}] TCP에서 EstimatedRTT를 계산하기 위해 사용되는 EWMA (Exponential Weighted Moving Average) 공식과 $\alpha$의 일반적인 값을 제시하시오.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item 공식: EstimatedRTT = \ansline{8cm}
    \item $\alpha$의 값: \ansline{3cm}
\end{enumerate}

\item[\textbf{22.}] Timeout Interval은 EstimatedRTT와 DevRTT를 기반으로 계산되며, EstimatedRTT의 변동폭이 클수록 더 큰 안전 마진을 원한다. Timeout Interval을 계산하는 공식을 제시하시오.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item TimeoutInterval = \ansline{8cm}
\end{enumerate}

\item[\textbf{23.}] Host A와 B가 TCP 연결로 통신 중이며, Host B는 이미 126번 바이트까지 모든 데이터를 수신했다. Host A가 Seq=127인 80바이트의 데이터(S1)를 포함하는 세그먼트와 이어서 40바이트의 데이터(S2)를 포함하는 세그먼트를 보냈다.
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item S2 세그먼트의 Sequence Number는 무엇인가? \ansline{3cm}
    \item 만약 S2가 S1보다 먼저 도착했다면, B가 S2 수신 후 즉시 A에게 보내는 ACK의 Acknowledgement Number는 무엇인가? \ansline{3cm}
\end{enumerate}

\item[\textbf{24.}] TCP Flow Control의 목적을 설명하고, 수신자가 광고하는 rwnd 값은 무엇을 나타내는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item 목적: \ansline{8cm}
    \item rwnd: \ansline{8cm}
\end{enumerate}

\item[\textbf{25.}] Host A와 B가 100 Mbps 링크로 연결되어 있고, A가 B에게 대용량 파일을 전송한다. A는 데이터를 120 Mbps로 소켓에 넣을 수 있지만, B가 데이터를 읽어내는 최대 속도는 50 Mbps이다. TCP Flow Control이 이 상황에서 어떻게 작동하며, 궁극적으로 데이터 전송 속도에 어떤 영향을 미치는지 설명하시오.
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{26.}] TCP Fast Retransmit 메커니즘의 작동 원리를 설명하시오. 즉, 송신자가 무엇을 몇 번 받았을 때 Timeout을 기다리지 않고 재전송을 시작하는가?
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}


\item[] \sectionbox{V. TCP Congestion Control (12문제)}

\item[\textbf{27.}] 혼잡(Congestion)의 두 가지 주요 징후(manifestations)는 무엇인가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{6cm}
    \item \ansline{6cm}
\end{enumerate}

\item[\textbf{28.}] TCP는 혼잡 제어를 위해 네트워크로부터 명시적인 피드백을 받지 않는다. TCP에서 혼잡은 일반적으로 어떤 이벤트(loss event)를 통해 추론되며, 혼잡이 감지되면 TCP 송신자의 전송률(Congestion Window Size, cwnd)은 어떻게 변화하는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item Loss event: \ansline{6cm}
    \item cwnd 변화: \ansline{6cm}
\end{enumerate}

\item[\textbf{29.}] TCP Congestion Control의 목표는 네트워크를 혼잡시키지 않으면서도 사용 가능한 모든 대역폭을 활용하는 것이다. TCP 송신자가 이를 위해 전송률을 조정하는 주기적인 행동 패턴을 AIMD와 연관 지어 설명하시오.
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{30.}] Slow Start (SS) 단계에서 cwnd가 RTT당 지수적으로 증가하는 방식을 설명하고, 구체적으로 ACK가 수신될 때마다 cwnd가 어떻게 증가하는지 설명하시오.
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{31.}] TCP에서 Slow Start가 끝나고 Congestion Avoidance (CA) 단계로 전환되는 임계값 변수인 ssthresh는 언제, 그리고 어떤 값으로 설정되는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item 언제: \ansline{6cm}
    \item 값: \ansline{6cm}
\end{enumerate}

\item[\textbf{32.}] TCP Tahoe와 TCP Reno를 비교할 때, Timeout으로 손실이 감지되었을 경우 ssthresh와 cwnd가 어떻게 설정되는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item ssthresh = \ansline{6cm}
    \item cwnd = \ansline{6cm}
\end{enumerate}

\item[\textbf{33.}] TCP Reno에서 Triple Duplicate ACK로 손실이 감지되었을 경우, cwnd와 ssthresh는 어떻게 설정되며, 이후 송신자는 어떤 상태(Phase)로 진입하는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item cwnd = \ansline{4cm}
    \item ssthresh = \ansline{4cm}
    \item 진입 상태: \ansline{4cm}
\end{enumerate}

\item[\textbf{34.}] 두 호스트 A와 B가 각각 1개의 TCP 연결을 사용하여 속도 $R$의 병목 링크를 공유한다. 두 연결이 동일한 RTT를 가진다고 가정하고, 혼잡 회피(Congestion Avoidance) 단계에서 두 연결이 대역폭을 공평하게 공유하는 이유를 AIMD의 그래프(Sawtooth) 움직임과 연관 지어 설명하시오.
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}

\item[\textbf{35.}] 만약 두 TCP 연결 (C1, C2)이 동일한 병목 링크(속도 R)를 공유하고, C1의 RTT는 50msec, C2의 RTT는 100msec이라고 가정하자. 두 연결 모두 혼잡 회피 단계에 있을 때, 장기적으로 두 연결이 병목 링크의 대역폭을 공평하게 분배받을 수 있는가?
\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item 답: \ansline{2cm}
    \item 이유: \ansline{10cm}
\end{enumerate}

\item[\textbf{36.}] TCP CUBIC은 기존 TCP AIMD와 달리 $W_{max}$ (혼잡 손실이 감지되었던 창 크기)를 목표로 하여 cwnd를 조정한다. CUBIC은 $W_{max}$에 가까워질수록 cwnd 증가 속도를 어떻게 변화시키는가?
\begin{enumerate}[label={}, itemsep=0.3em, leftmargin=1.5em]
    \item \ansline{12cm}
\end{enumerate}


\item[] \sectionbox{VI. 계산 및 분석 문제 (2문제)}

\item[\textbf{37.}] \textbf{[TCP RTT 추정 계산]} 주어진 $\alpha = 0.125$ 및 $\beta = 0.25$ 값을 사용하여, 초기 EstimatedRTT가 100ms, 초기 DevRTT가 5ms라고 가정한다. 다음 SampleRTT 측정값이 차례대로 얻어졌을 때, 각 단계별 EstimatedRTT, DevRTT, TimeoutInterval을 계산하여 표를 완성하시오.
\begin{itemize}[leftmargin=1.5em]
    \item $EstimatedRTT = (1-\alpha) \times EstimatedRTT + \alpha \times SampleRTT$
    \item $DevRTT = (1-\beta) \times DevRTT + \beta \times |SampleRTT - EstimatedRTT|$
    \item $TimeoutInterval = EstimatedRTT + 4 \times DevRTT$
\end{itemize}

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Sample No.} & \textbf{SampleRTT (ms)} & \textbf{EstimatedRTT (ms)} & \textbf{DevRTT (ms)} & \textbf{TimeoutInterval (ms)} \\
    \hline
    초기 값 & - & 100 & 5 & 120 (100+4*5) \\
    \hline
    1 & 106 & \ansline{2cm} & \ansline{2cm} & \ansline{2cm} \\
    \hline
    2 & 120 & \ansline{2cm} & \ansline{2cm} & \ansline{2cm} \\
    \hline
\end{tabular}
\end{center}

\item[\textbf{38.}] \textbf{[TCP Congestion Control 분석]} TCP Reno 환경에서 cwnd 크기가 시간에 따라 증가하는 다음 시나리오를 가정하자.

\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \textbf{Round} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 \\
    \hline
    \textbf{cwnd (MSS)} & 1 & 2 & 4 & 8 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 & 12 & 13 & 14 \\
    \hline
\end{tabular}
\end{center}

\begin{enumerate}[label=\alph*., itemsep=0.3em, leftmargin=1.5em]
    \item TCP Slow Start가 작동하는 구간을 Transmission Round 번호로 표시하시오: \ansline{4cm}
    \item TCP Congestion Avoidance가 작동하는 구간을 Transmission Round 번호로 표시하시오: \ansline{4cm}
    \item 13번째 라운드가 끝난 후(14라운드 시작 전)에 손실이 감지되었는데, 이 손실이 Timeout으로 감지되었는가, 아니면 Triple Duplicate ACK로 감지되었는가? \ansline{5cm}
    \item 14번째 Transmission Round 직전에 ssthresh 값은 얼마였는가? \ansline{4cm}
\end{enumerate}

\end{enumerate}

\vfill
\begin{center}
  \rule{0.9\textwidth}{0.4pt}\\[8pt]
  {\small\textbf{--- 수고하셨습니다 ---}}\\[6pt]
  {\scriptsize ※ 본 문제지는 학습 목적으로 제작되었습니다.}
\end{center}

\end{document}
